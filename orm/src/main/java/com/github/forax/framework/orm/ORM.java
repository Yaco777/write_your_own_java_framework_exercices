package com.github.forax.framework.orm;

import javax.sql.DataSource;

import java.beans.BeanInfo;
import java.beans.FeatureDescriptor;
import java.beans.Introspector;
import java.beans.PropertyDescriptor;
import java.io.Serial;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Proxy;
import java.sql.*;
import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public final class ORM {
  private ORM() {
    throw new AssertionError();
  }




  @FunctionalInterface
  public interface TransactionBlock {
    void run() throws SQLException;
  }

  private static final Map<Class<?>, String> TYPE_MAPPING = Map.of(
      int.class, "INTEGER",
      Integer.class, "INTEGER",
      long.class, "BIGINT",
      Long.class, "BIGINT",
      String.class, "VARCHAR(255)"
  );

  private static Class<?> findBeanTypeFromRepository(Class<?> repositoryType) {
    var repositorySupertype = Arrays.stream(repositoryType.getGenericInterfaces())
        .flatMap(superInterface -> {
          if (superInterface instanceof ParameterizedType parameterizedType
              && parameterizedType.getRawType() == Repository.class) {
            return Stream.of(parameterizedType);
          }
          return null;
        })
        .findFirst()
        .orElseThrow(() -> new IllegalArgumentException("invalid repository interface " + repositoryType.getName()));
    var typeArgument = repositorySupertype.getActualTypeArguments()[0];
    if (typeArgument instanceof Class<?> beanType) {
      return beanType;
    }
    throw new IllegalArgumentException("invalid type argument " + typeArgument + " for repository interface " + repositoryType.getName());
  }

  private static class UncheckedSQLException extends RuntimeException {
    @Serial
    private static final long serialVersionUID = 42L;

    private UncheckedSQLException(SQLException cause) {
      super(cause);
    }

    @Override
    public SQLException getCause() {
      return (SQLException) super.getCause();
    }
  }


  // --- do not change the code above


  private static final ThreadLocal<Connection> CONNECTION_THREAD_LOCAL = new ThreadLocal<>();


  public static void transaction(DataSource dataSource, TransactionBlock block) throws SQLException {

    try(var connection = dataSource.getConnection()) {

      CONNECTION_THREAD_LOCAL.set(connection);
      try {
        connection.setAutoCommit(false);
        block.run();
        connection.commit();

      } catch (SQLException e) {
        connection.rollback();
        throw e;
      } catch(UncheckedSQLException error) {
        connection.rollback();
        throw error.getCause();
      }
      finally {
        CONNECTION_THREAD_LOCAL.remove();
      }
    }
  }

  public static Connection currentConnection() {
    var connection = CONNECTION_THREAD_LOCAL.get();
    if(connection == null) {
      throw new IllegalStateException("No connection available");
    }
    return connection;

  }

   static String findTableName(Class<?> beanClass) {

    var table = beanClass.getAnnotation(Table.class);
    //the getSimpleName will return the name of the class without the package
    var name =  table == null ? beanClass.getSimpleName() : table.value();
    return name.toUpperCase(Locale.ROOT);

  }

  private static boolean isAutoGenerated(PropertyDescriptor property) {
    var getter = getGetterMethod(property);
    return getter.isAnnotationPresent(GeneratedValue.class);
  }

  private static boolean isPrimaryKey(PropertyDescriptor property) {
    var getter = getGetterMethod(property);
    return getter.isAnnotationPresent(Id.class);
  }

  private static Method getGetterMethod(PropertyDescriptor property) {
    return property.getReadMethod();
  }

  static String findColumnName(PropertyDescriptor property) {

    var getter = property.getReadMethod();
    if(getter == null) {
      throw new IllegalStateException("No guetter for property "+property.getName());
    }
    var column = getter.getAnnotation(Column.class);
    var name =  column == null ? property.getName() : column.value();
    return name.toUpperCase(Locale.ROOT);
  }

  public static void createTable(Class<?> furnitureClass) throws SQLException {
    Objects.requireNonNull(furnitureClass);
    var tableName = findTableName(furnitureClass);
    var query = "CREATE TABLE "+tableName+" "+Arrays.stream(Utils.beanInfo(furnitureClass).getPropertyDescriptors())
            .filter(property -> !property.getName().equals("class"))
            .map(ORM::apply)
            .collect(Collectors.joining(",\n","(\n",");\n"));


    var connection = ORM.currentConnection();


    try(var statement = connection.createStatement()) {
      statement.executeUpdate(query);
    }

  }
  private static String apply(PropertyDescriptor property) {


    var column = ORM.findColumnName(property);
    var type = property.getPropertyType();
    var typeName = TYPE_MAPPING.get(type);
    if (typeName == null) {
      throw new IllegalStateException("Unknown type " + type.getName());
    }
    var notNull = type.isPrimitive() ? " NOT NULL" : "";
    var autoIncrement = isAutoGenerated(property) ? " AUTO_INCREMENT " : "";
    var primaryKey = isPrimaryKey(property) ? ", PRIMARY KEY ("+column+")" : "";

    return column + " " + typeName + notNull + autoIncrement+primaryKey;

  }

  public static <T extends Repository<?,?>> T createRepository(Class<T> repositoryClass) {
    Objects.requireNonNull(repositoryClass);
    var beanType = findBeanTypeFromRepository(repositoryClass);
    var beanInfo = Utils.beanInfo(beanType);
    var tableName = findTableName(beanType);
    var sqlQuery = "SELECT * FROM " + tableName;
    var constructor = Utils.defaultConstructor(beanType);
    var objectProxy = Proxy.newProxyInstance(repositoryClass.getClassLoader(), new Class<?>[] {repositoryClass},
            (Object proxy, Method method, Object[] args) -> {
              try {
                return switch(method.getName()) {
                  case "findAll" -> {

                    yield findAll(ORM.currentConnection(), sqlQuery, beanInfo, constructor);
                  }
                  case "findById" -> findAll(currentConnection(),"SELECT * FROM "+tableName+" WHERE "+findColumnName(findId(beanInfo)) +" = ?",beanInfo,constructor,args[0])
                          .stream().findFirst();
                  case "equals", "hashCode", "toString" -> throw new UnsupportedOperationException("method "+method+" not supported");
                  case "save" -> save(ORM.currentConnection(), tableName, Utils.beanInfo(beanType), args[0],findId(beanInfo));

                  default -> {

                    var query = method.getAnnotation(Query.class);
                    if (query != null) {
                      var arguments = args == null ? new String[0] : args; //tableau non modifiable alors que ceux de taille >= 1 sont mutable
                      yield findAll(ORM.currentConnection(),query.value(), beanInfo, constructor,arguments);
                    }
                    if(method.getName().startsWith("findBy")) {

                      var propertyName = Introspector.decapitalize(method.getName().substring("findBy".length()));
                      var propertyFind = findProperty(beanInfo,propertyName);
                      var list =  findByProperty(currentConnection(),tableName,beanInfo,constructor,propertyFind,args);
                      yield method.getReturnType() == Optional.class ? list.stream().findFirst() : list;

                    }

                    throw new IllegalStateException("Method not supported " + method);
                  }
                };
              } catch (SQLException e) {
                throw new UncheckedSQLException(e);
              }

            });

    return repositoryClass.cast(objectProxy);

  }

  private static List<?> findAll(Class<?> beanType) throws SQLException {
    var connection = currentConnection();
    var constructor = Utils.defaultConstructor(beanType); // constructor without any parameter
    var tableName = findTableName(beanType);
    var beanInfo = Utils.beanInfo(beanType);
    var properties = beanInfo.getPropertyDescriptors();
    String sqlQuery = "SELECT * FROM "+tableName;
    try(var statement = connection.prepareStatement(sqlQuery)) {
      var list = new ArrayList<>();
      try(var resultSet = statement.executeQuery()) {
        while(resultSet.next()) {

          var instance = Utils.newInstance(constructor);
          var index = 1; // h2 index start at 1 and not 0
          for (var property : properties) {
            if(property.getName().equals("class")) {
              continue;
            }
            var value = resultSet.getObject(index++);
            var setter = property.getWriteMethod();
            Utils.invokeMethod(instance, setter,value);

          }
          list.add(instance);
        }
        return list;
      }
    }

    }

    static Object toEntityClass(ResultSet resultSet,BeanInfo beanInfo,Constructor<?> constructor)  throws SQLException {


      var instance = Utils.newInstance(constructor);
      for(var property : beanInfo.getPropertyDescriptors()) {
        //we remove the "class"
        if(property.getName().equals("class")) {
          continue;
        }
  
        //We call the setter with the correct value from the resultSet
        var setterValue = resultSet.getObject(property.getName());
        var setter = property.getWriteMethod();
        Utils.invokeMethod(instance,setter,setterValue);

      }

      return instance;

    }

   

    static List<Object> findAll(Connection connection,String sqlQuery,BeanInfo beanInfo,Constructor<?> constructor) throws SQLException{

      var list = new ArrayList<>();
      try(var statement = connection.prepareStatement(sqlQuery)) {
       
        try(var resultSet = statement.executeQuery()) {
          while(resultSet.next()) {
            var instance = toEntityClass(resultSet,beanInfo,constructor);
            list.add(instance);
          }
          return list;
        }
      } 
     
    
  }

   static String createSaveQuery(String tableName,BeanInfo beanInfo) {
//    var insertInto = "INSERT INTO "+tableName+" ";
//    var columns = Arrays.stream(beanInfo.getPropertyDescriptors())
//            .map(FeatureDescriptor::getName)
//            .filter(name -> !name.equals("class"))
//            .collect(Collectors.joining(", ","(",")"));
//
//    //we need to add a (?) in the values for each columns
//    var values = Arrays.stream(beanInfo.getPropertyDescriptors())
//            .filter(property -> !property.getName().equals("class"))
//            .map(property -> "?")
//            .collect(Collectors.joining(", ","(",")"));
//    var a = insertInto + columns + " VALUES " + values+ ";";
    var properties = beanInfo.getPropertyDescriptors();
    return """
             MERGE INTO %s %s VALUES (%s);"""
            .formatted(tableName,
            Arrays.stream(properties)
                    .filter(property -> !property.getName().equals("class"))
                    .map(ORM::findColumnName)
                    .collect(Collectors.joining(", ","(",")")),
            String.join(", ",Collections.nCopies(properties.length - 1,"?"))
    );
  }

  public static Object save(Connection connection,String tableName,BeanInfo beanInfo,Object bean,PropertyDescriptor idProperty) throws SQLException {

    var query = createSaveQuery(tableName,beanInfo);
    try(var statement = connection.prepareStatement(query, Statement.RETURN_GENERATED_KEYS)) {
      var columnIndex = 1; //we start at 1 for the column index
      for(var property : beanInfo.getPropertyDescriptors()) {

        if(property.getName().equals("class")) {
          continue;
        }
        var value = Utils.invokeMethod(bean,getGetterMethod(property));
        statement.setObject(columnIndex, value);
        columnIndex++;
      }
      statement.executeUpdate();
      if(idProperty != null) {
        try(var resultSet = statement.getGeneratedKeys()) {
          if(resultSet.next()) {
            var idValue = resultSet.getObject( 1);
            Utils.invokeMethod(bean, idProperty.getWriteMethod(), idValue);


          }
      }

      }


    }

    return bean;



  }
  static PropertyDescriptor findId(BeanInfo beanInfo) {
    var propertiesId =  Arrays.stream(beanInfo.getPropertyDescriptors())
            .filter(ORM::isPrimaryKey)
            .toList();
    return switch(propertiesId.size()) {
      case 0 -> null;
      case 1 -> propertiesId.getFirst();
      default -> throw new IllegalStateException("You have too many id !!");
    };
  }

  static List<?> findAll(Connection connection, String sqlQuery,BeanInfo beanInfo, Constructor<?> constructor, Object ...args) throws SQLException {
    var list = new ArrayList<>();

    try(var statement = connection.prepareStatement(sqlQuery)) {
      for(var i = 0; i < args.length; i++) {
        var arg = args[i];
        statement.setObject(i+1,arg);
      }
      try(var resultSet = statement.executeQuery()) {
        while(resultSet.next()) {
          var instance = toEntityClass(resultSet,beanInfo,constructor);
          list.add(instance);
        }
      }

    }
    return list;

  }

  public static PropertyDescriptor findProperty(BeanInfo beanInfo, String name) {

    var propertyFind =  Arrays.stream(beanInfo.getPropertyDescriptors())
            .filter(property -> property.getName().equals(name)).findFirst();
      return propertyFind.orElseThrow();


  }

  static List<?> findByProperty(Connection connection, String tableName, BeanInfo beanInfo, Constructor<?> constructor, PropertyDescriptor property, Object ...args) throws SQLException {
    return findAll(connection,
            "SELECT * FROM "+tableName+" WHERE "+findColumnName(property) + " = ?", beanInfo, constructor,args[0]);
  }





}




